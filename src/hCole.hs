{-# LANGUAGE DeriveDataTypeable #-}
{-

Entrypoint to the Haskell COLE implementation.

This module simply uses functionality provided by other modules, e.g., 
  - for generating random entities
  - for evaluating a given set of entities
  - for building a model based om measured data
  - for exploring using a model or actual evaluation
  - ...

If you have additional backends, compiler suites, benchmarks, ... that you wish to use, 
you should add them to the option lists and provide the implementation.

-}

module Main 
  ( main
  )where

import System.Console.CmdArgs

--import GA

import qualified Cole.Benchmark as Benchmark
import qualified Cole.Compiler as Compiler
import qualified Cole.Entity as Entity
import qualified Cole.Model as Model
--import qualified Cole.Exploration as Exploration


--------------------------------------------------------------------------------
-- data structures for the command line arguments
--
-- FIXME: this should be split into multiple sections, since we probably want to 
--        split the exploration into different actions. Moreover, we might want
--        to start any of the actions with a predefined set of data that need not
--        have been generated by hCole.
--        
--
data ColeCmdLineArgs = ColeGenerateArgs { compiler :: Compiler.ColeCompilerType
                                        , suite :: Benchmark.ColeSuiteType -- FIXME: should be possible to provide multiple suites
                                        , benchmarks :: String  
                                        , number :: Int
                                        , maxPasses :: Int
                                        , passes :: Int
                                        , output :: FilePath
                                        }
                     | ColeEvaluateArgs { compiler :: Compiler.ColeCompilerType
    , suite :: Benchmark.ColeSuiteType -- FIXME: should be possible to provide multiple suites
    , benchmarks :: String  
    , entitiesFile :: FilePath
    , random :: Bool
    , output :: FilePath
    } 
                     | ColeModelArgs
    { -- compiler :: Compiler.ColeCompilerType
    --, suite :: Benchmark.ColeSuiteType -- FIXME: should be possible to provide multiple suites
    --, benchmarks :: String  
    model :: Model.ColeModelType
    , entitiesFile :: FilePath
    -- , evaluate :: Bool -- FIXME: not for now.
    , evaluationFile :: FilePath
    , output :: FilePath
    } 
                      |  ColeExplorationArgs
    { compiler :: Compiler.ColeCompilerType
    , suite :: Benchmark.ColeSuiteType -- FIXME: should be possible to provide multiple suites
    , benchmarks :: String  
    , modelFile :: FilePath
    , evaluation :: Bool 
    , output :: FilePath
    } deriving (Show, Data, Typeable)

outputFlags f   = f &= name "output" &= typFile &= help "Output file"
entityFlags f   = f &= name "entities" &= typFile &= help "File with the entities in Readable format"
evaluateFlags f = f &= name "evaluation" &= typFile &= help "File containing the evaluation results."
modelFlags f    = f &= name "model" &= typFile &= help "File containing the model to use during the exploration."

hColeGenerateArgs = ColeGenerateArgs
    { compiler     = Compiler.None &= explicit &= name "compiler" &= help "The compiler to tune."
    , suite        = Benchmark.None &= explicit &= name "suite" &= help "The benchmark suite to use for tuning."
    , benchmarks   = "" &= explicit &= name "benchmarks" &= help "The benchmarks from the suite to use."
    , number       = def &= explicit &= name "number" &= help "Number of entities to generate."
    , maxPasses    = def &= explicit &= name "length" &= help "Maximum of passes per set."
    , passes       = def &= explicit &= name "passes" &= help "Number of passes to choose from."
    , output       = outputFlags "generated.entities.txt"
    }

hColeEvaluateArgs = ColeEvaluateArgs
    { compiler     = Compiler.None &= explicit &= name "compiler" &= help "The compiler to tune."
    , suite        = Benchmark.None &= explicit &= name "suite" &= help "The benchmark suite to use for tuning."
    , benchmarks   = "" &= explicit &= name "benchmarks" &= help "The benchmarks from the suite to use."
    , entitiesFile = entityFlags "generated.entities.txt"
    , random       = False &= explicit &= name "random" &= help "Randomly generate a set of random entities to bootstrap the search."
    , output       = outputFlags "evaluated.entities.txt"
    }

hColeModelArgs = ColeModelArgs
    { model           = Model.None &= explicit &= name "model" &= help "Modeling algorithm to use"
    , entitiesFile    = entityFlags "generated.entities.txt" 
    , evaluationFile  = evaluateFlags "evaluated.exities.x"
    , output          = outputFlags "model.entities.txt"
    }

hColeExplorationArgs = ColeExplorationArgs
    { compiler       = Compiler.None &= explicit &= name "compiler" &= help "The compiler to tune."
    , suite          = Benchmark.None &= explicit &= name "suite" &= help "The benchmark suite to use for tuning."
    , benchmarks     = "" &= explicit &= name "benchmarks" &= help "The benchmarks from the suite to use."
    , modelFile      = modelFlags "model.entities.txt"
    , evaluation     = False -- FIXME: in the end we also want to conduct full sclae explorations
    , output         = outputFlags "explored.entities.txt"
    }

hColeModes = modes [hColeGenerateArgs, hColeEvaluateArgs, hColeModelArgs, hColeExplorationArgs]
    &= help "Compiler Optimisation Level Exploration (COLE)."
    &= summary "hCole v 0.1, (C) 2011 Andy Georges. Based on COLE, by Kenneth Hoste."


main = do 
    putStrLn "I am your COLE."

    args <- cmdArgs hColeModes

    putStrLn "I am done."
  

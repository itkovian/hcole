{-

Entrypoint to the Haskell COLE implementation.

This module simply uses functionality provided by other modules, e.g., 
  - for generating random entities
  - for evaluating a given set of entities
  - for building a model based om measured data
  - for exploring using a model or actual evaluation
  - ...

If you have additional backends, compiler suites, benchmarks, ... that you wish to use, 
you should add them to the option lists and provide the implementation.

-}

module Main 
  (
  )where

import System.Console.CmdArgs

--import GA

import qualified Cole.Benchmark as Benchmark
import qualified Cole.Compiler as Compiler
import qualified Cole.Entity as Entity
import qualified Cole.Exploration as Exploration


--------------------------------------------------------------------------------
-- data structures for the command line arguments
--
-- FIXME: this should be split into multiple sections, since we probably want to 
--        split the exploration into different actions. Moreover, we might want
--        to start any of the actions with a predefined set of data that need not
--        have been generated by hCole.
--        
data ColeGenerateArgs = ColeGenerateArgs
    { compiler :: Compiler.ColeCompilerType
    , suite :: Benchmark.ColeSuiteType -- FIXME: should be possible to provide multiple suites
    , benchmarks :: String  
    , number :: Int
    , length :: Int
    , passes :: Int
    , output :: FilePath
    } deriving (Show, Data, Typeable)

data ColeEvaluateArgs = ColeEvaluateArgs
    { compiler :: Compiler.ColeCompilerType
    , suite :: Benchmark.ColeSuiteType -- FIXME: should be possible to provide multiple suites
    , benchmarks :: String  
    , entities :: FilePath
    , random :: Bool
    , output :: FilePath
    } deriving (Show, Data, Typeable)
    
data ColeModelArgs = ColeModelArgs
    { -- compiler :: Compiler.ColeCompilerType
    --, suite :: Benchmark.ColeSuiteType -- FIXME: should be possible to provide multiple suites
    --, benchmarks :: String  
    , model :: Model.ColeModelType
    , entities :: FilePath
    -- , evaluate :: Bool -- FIXME: not for now.
    , evalution :: FilePath
    , output :: FilePath
    } deriving (Show, Data, Typeable)

data ColeExplorationArgs = ColeExplorationArgs
    { compiler :: Compiler.ColeCompilerType
    , suite :: Benchmark.ColeSuiteType -- FIXME: should be possible to provide multiple suites
    , benchmarks :: String  
    , model :: FilePath
    , evaluation :: Bool
    , output :: FilePath
    } deriving (Show, Data, Typeable)

outputFlags f   = f &= name = "output" &= typFile &= help "Output file"
entityFlags f   = f &= name = "entities" &= typFile &= help "File with the entities in Readable format"
evaluateFlags f = f &= name = "model" &= typeFile &= help "File containing the evaluation results."

hColeGenerateArgs = ColeGenerateArgs
    { compiler     = ColeLLVM &= explicit &= name "compiler" &= help "The compiler to tune."
    , suite        = ColeSPECCPU2000 &= explicit &= name "suite" &= help "The benchmark suite to use for tuning."
    , benchmarks   = "" &= explicit &= name "benchmarks" &= help "The benchmarks from the suite to use."
    , number       = def &= explicit &= name "number" &= help "Number of entities to generate."
    , length       = def &= explicit &= name "length" &= help "Maximum of passes per set."
    , passes       = def &= explicit &= name "passes" &= help "Number of passes to choose from."
    , output       = outputFlags "generated.entities.txt"
    }

hColeEvaluateArgs = ColeEvaluateArgs
    { compiler     = ColeLLVM &= explicit &= name "compiler" &= help "The compiler to tune."
    , suite        = ColeSPECCPU2000 &= explicit &= name "suite" &= help "The benchmark suite to use for tuning."
    , benchmarks   = "" &= explicit &= name "benchmarks" &= help "The benchmarks from the suite to use."
    , entitiesFile = entityFlags "generated.entities.txt"
    , random       = False &= explicit &= name "random" &= help "Randomly generate a set of random entities to bootstrap the search."
    , output       = outputFlags "evaluated.entities.txt"
    }

hColeModelArgs = ColeModelArgs
    { model           = ColeM5 &= explicit &= name "model" &= help "Modeling algorithm to use"
    , entitiesFile    =  
    , evaluationFile = evaluateFlags "evaluated.exities.x"
    , output = outputFlags "model.entities.txt"
    }

hColeExplorationArgs = ColeExplorationArgs
    { compiler     = ColeLLVM &= explicit &= name "compiler" &= help "The compiler to tune."
    , suite        = ColeSPECCPU2000 &= explicit &= name "suite" &= help "The benchmark suite to use for tuning."
    , benchmarks   = "" &= explicit &= name "benchmarks" &= help "The benchmarks from the suite to use."
    , evaluation   = False -- FIXME: in the end we also want to conduct full sclae explorations
    , output       = outputFlags "explored.entities.txt"
    }

hColeModes = modes [hColeGenerateArgs, hColeEvaluateArgs, hColeModelArgs, hColeExplorationArgs]
    &= help "Compiler Optimisation Level Exploration (COLE)."
    &= summary "hCole v 0.1, (C) 2011 Andy Georges. Based on COLE, by Kenneth Hoste."


main = do 
    putStrLn "I am your COLE."

    args <- cmdArgs ColeCmdArgs


    putStrLn "I am done."
  
